Лабораторна робота №7. Функції
Придворов Сергій Володимирович, гр. КІТ-121в.

Переробити програми, що були розроблені під час виконання лабораторних робіт з тем
“Масиви” та “Цикли” таким чином, щоб використовувалися функції для обчислення результату.

Опис роботи: Для початку додамо бібліотеки: 
#include <stdlib.h>
#include <stdio.h>

Зробимо константу a:
#define a 3

Задамо функції, якими будемо користуватися:
int cicle();
int array();

Перейдемо до основної функції main():
1. Задаємо масив, та заповнюємо його числами:
int arr1[a][a];
	int arr2[a * a];
	int c = 0;
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr1[i][j] = i + 2 * j;
		}
	}
2. Перетвоюємо масив з двовимірного в одномірний для передачі у функцію:
for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr2[c] = arr1[i][j];
			c++;
		}
	} 
3. Викликаемо функцію для визначення простого числа, та виводимо результат на екран.
	
int resc = cicle(rand() % 100);

	if (resc == 1)
	{
		printf("%s", "Число простое!");
	}
	if (resc == 0)
	{
		printf("%s", "Число не простое!");
	}
	 printf("\n");
_______________________________________________________________________________________
ФУНКЦІЯ МНОЖЕННЯ МАТРИЦІ САМУ НА СЕБЕ.
1. Створюємо необхідні для використання масиви та змінні, а потім перетворюємо вхідну одномірну матрицю в двумірну:
int arr4[a][a];
	int v = 0;
	int arr5[a][a];
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr4[i][j] = arr3[v];
			v++;
		}
	}
2. Множимо на себе відповідно до правил множення матриць (строка на стовпчик):
for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr5[i][j] = 0;
			for (int k = 0; k < a; k++)
			{
				arr5[i][j] += arr4[i][k] * arr4[k][j];
			}
		}
	}
3. Вимодимо масив на екран:

	for (int i = 0; i < a; i++)
{
        for (int j = 0; j < a; j++)
        {
                printf("%4d", arr5[i][j]);
        }
        printf("\n");
}
_______________________________________________________________________________________
ФУНКЦИЯ ПЕРЕВІРКИ ПРОСТОГО ЧИСЛА.
1. Задаємо змінну, яка буде ідентефікатором.
int b;
2. Задаємо цикл, від числа, яке треба перевірити - 1, до 1, та постійно зменшуємо на один.
for (int i = n - 1; i > 1; i--)
	{
3. Відповідно до правил визначення простого числа (ділення з остачею чи ні) робимо перевірку:
		if (n % i != 0)
		{
			b = 1; //простое
		}
		if (n % i == 0)
		{
			b = 0; //не простое
			break;
		}
якщо у числа є залишок серед ділення, то число просте, і b = 1, якщо навпаки, то b = 0, та функция запуняється.
3. Повертає значення b.

Спробуемо виконати код:
(lldb) run
Process 8143 launched: '/home/sergey/Рабочий стол/123/programing_pridvorov/lab08/dist/main.bin' (x86_64)
  10  22  34
  13  31  49
  16  40  64

(lldb) p b
(int) $0 = 1

```

sergey@sergey-VirtualBox:~/Рабочий стол/123/programing_pridvorov/lab08$ make run
rm -rf dist
mkdir dist
clang -std=gnu11 -g -Wall -Wextra -Werror -Wformat-security -Wfloat-equal -Wshadow -Wconversion -Wlogical-not-parentheses -Wnull-dereference -Wno-unused-variable -Werror=vla  src/main.c -o ./dist/main.bin
./dist/main.bin
  10  22  34
  13  31  49
  16  40  64
Число простое!
sergey@sergey-V
```

## Висновки
Шляхом математичний рохрахунків можно визначити, що результат правильний.

Код:

/**
 * @mainpage
 * # Загальне завдання
 * 1. **Сформувати** функцию, що визначає чи число простим.
 *
 * 2. **Сформувати** функцію, яка множить матрицу на себе.
 *
 * @author Pridvorov Sergey
 * @date 11-dec-2021
 * @version 1
 */

/**
 * @file main.c
 * @brief Лабораторна работа №7-8
 *
 * @author Pridvorov Sergey
 * @date 11-dec-2021
 * @version 1
 */

#include <stdlib.h>
#include <stdio.h>
#define a 3
int cicle();
int array();
/**
 * Головна функція.
 *
 * Послідовність дій:
 * - створення масиву та його заповнення {@link arr1}
 * - перетворення двовимірного масиву в одновимірний
 * {@arr2}
 * - за допомогою функції вивід чи є число простим
 * {@resc}
 * @return успішний код повернення з програми (0)
 */
int main()
{
	int arr1[a][a];
	int arr2[a * a];
	int c = 0;
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr1[i][j] = i + 2 * j;
		}
	}
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr2[c] = arr1[i][j];
			c++;
		}
	}
	array(arr2);

	int resc = cicle(rand() % 100);

	if (resc == 1)
	{
		printf("%s", "Число простое!");
	}
	if (resc == 0)
	{
		printf("%s", "Число не простое!");
	}
	 printf("\n");

	return 0;
}

/**
 * Функція множення матрицi на себе
 *
 * Послідовність дій:
 * - перетворення одновимірного масиву в двовимірний {@link arr4}
 * - вiдповiдно до правил множення матриць множиння на себе матрицi
 * {@arr5}
 * - вивід отриманої матриці
 * @return успішний код повернення з програми (0)
 */
int array(int arr3[])
{
	int arr4[a][a];
	int v = 0;
	int arr5[a][a];
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr4[i][j] = arr3[v];
			v++;
		}
	}
	for (int i = 0; i < a; i++)
	{
		for (int j = 0; j < a; j++)
		{
			arr5[i][j] = 0;
			for (int k = 0; k < a; k++)
			{
				arr5[i][j] += arr4[i][k] * arr4[k][j];
			}
		}
	}


	for (int i = 0; i < a; i++)
{
        for (int j = 0; j < a; j++)
        {
                printf("%4d", arr5[i][j]);
        }
        printf("\n");
}
	return 0;
}

/**
 * Функція визначення чи є число простим
 *
 * Послідовність дій:
 * - створення змінної яка буде ідентифікувати число як просте чи навпаки {@b}
 * - перевірка числа за допомогою ділення з остачею
 * @return успішний код повернення з програми (b)
 */

int cicle(n)
{
	int b;
	for (int i = n - 1; i > 1; i--)
	{
		if (n % i != 0)
		{
			b = 1; //простое
		}
		if (n % i == 0)
		{
			b = 0; //не простое
			break;
		}
	}
	return b;
}

Структура проекту лабораторної роботи:
		
└── lab07
├── Makefile
├── README.md
├── doc
│ └── lab07.txt
└── src
└── main.c

Висновки: при виконанні даної лабораторної роботи було набуто практичного досвіду 
роботи із функцiями та документацiєю.
